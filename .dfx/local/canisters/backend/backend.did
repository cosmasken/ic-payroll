type UserId = nat32;
type User = 
 record {
   created_at: int;
   email: text;
   email_notifications: bool;
   id: nat;
   name: text;
   phone: text;
   phone_notifications: bool;
   wallet: text;
 };
type Trie = 
 variant {
   branch: Branch;
   "empty";
   leaf: Leaf;
 };
type TransactionId = nat32;
type Transaction = 
 record {
   amount: nat;
   created_at: int;
   from: principal;
   memo: text;
   to: principal;
 };
type Subaccount = blob;
type Result = 
 variant {
   err: text;
   ok: text;
 };
type Response = 
 record {
   data: opt text;
   error_text: opt text;
   status: nat16;
   status_text: text;
 };
type List = 
 opt record {
       record {
         Key;
         User;
       };
       List;
     };
type Leaf = 
 record {
   keyvals: AssocList;
   size: nat;
 };
type Key = 
 record {
   hash: Hash;
   key: UserId;
 };
type Hash = nat32;
type Branch = 
 record {
   left: Trie;
   right: Trie;
   size: nat;
 };
type Backend = 
 service {
   create: (User) -> (UserId);
   delete: (UserId) -> (bool);
   getAllUsers: () -> (Trie) query;
   getCanisterAddress: () -> (text);
   getCanisterBalance: () -> (text);
   getFundingAddress: () -> (text);
   getFundingBalance: () -> (text);
   getInvoice: () -> (Account);
   getLogs: () -> (vec text) query;
   getTradingAddress: () -> (text);
   getTradingBalance: () -> (text);
   read: (UserId) -> (opt User) query;
   saveTransaction: (Transaction) -> (TransactionId);
   setCourierApiKey: (text) -> (Response);
   transactionsLength: () -> (text) query;
   transferFromCanistertoSubAccount: () -> (Result);
   transferFromSubAccountToSubAccount: (text, nat) -> (Result);
   update: (UserId, User) -> (bool);
   userLength: () -> (text) query;
   whoami: () -> (principal);
 };
type AssocList = 
 opt record {
       record {
         Key;
         User;
       };
       List;
     };
type Account = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
service : (nat) -> Backend
