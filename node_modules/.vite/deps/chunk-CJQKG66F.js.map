{
  "version": 3,
  "sources": ["../../@dfinity/agent/src/agent/api.ts", "../../@dfinity/agent/src/auth.ts", "../../@dfinity/agent/src/agent/http/types.ts", "../../@dfinity/agent/src/agent/http/transforms.ts", "../../@dfinity/agent/src/agent/http/index.ts", "../../@dfinity/agent/src/agent/proxy.ts", "../../@dfinity/agent/src/agent/index.ts", "../../@dfinity/agent/src/polling/index.ts", "../../@dfinity/agent/src/polling/strategy.ts", "../../@dfinity/agent/src/actor.ts", "../../@dfinity/agent/src/canisters/management_idl.ts", "../../@dfinity/agent/src/canisters/asset_idl.ts", "../../@dfinity/agent/src/canisters/asset.ts", "../../@dfinity/agent/src/fetch_candid.ts"],
  "sourcesContent": ["import { Principal } from '@dfinity/principal';\nimport { RequestId } from '../request_id';\nimport { JsonObject } from '@dfinity/candid';\nimport { Identity } from '../auth';\n\n/**\n * Codes used by the replica for rejecting a message.\n * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.\n */\nexport enum ReplicaRejectCode {\n  SysFatal = 1,\n  SysTransient = 2,\n  DestinationInvalid = 3,\n  CanisterReject = 4,\n  CanisterError = 5,\n}\n\n/**\n * Options when doing a {@link Agent.readState} call.\n */\nexport interface ReadStateOptions {\n  /**\n   * A list of paths to read the state of.\n   */\n  paths: ArrayBuffer[][];\n}\n\n/**\n *\n */\nexport type QueryResponse = QueryResponseReplied | QueryResponseRejected;\n\nexport const enum QueryResponseStatus {\n  Replied = 'replied',\n  Rejected = 'rejected',\n}\n\nexport interface QueryResponseBase {\n  status: QueryResponseStatus;\n}\n\nexport interface QueryResponseReplied extends QueryResponseBase {\n  status: QueryResponseStatus.Replied;\n  reply: { arg: ArrayBuffer };\n}\n\nexport interface QueryResponseRejected extends QueryResponseBase {\n  status: QueryResponseStatus.Rejected;\n  reject_code: ReplicaRejectCode;\n  reject_message: string;\n}\n\n/**\n * Options when doing a {@link Agent.query} call.\n */\nexport interface QueryFields {\n  /**\n   * The method name to call.\n   */\n  methodName: string;\n\n  /**\n   * A binary encoded argument. This is already encoded and will be sent as is.\n   */\n  arg: ArrayBuffer;\n}\n\n/**\n * Options when doing a {@link Agent.call} call.\n */\nexport interface CallOptions {\n  /**\n   * The method name to call.\n   */\n  methodName: string;\n\n  /**\n   * A binary encoded argument. This is already encoded and will be sent as is.\n   */\n  arg: ArrayBuffer;\n\n  /**\n   * An effective canister ID, used for routing. This should only be mentioned if\n   * it's different from the canister ID.\n   */\n  effectiveCanisterId: Principal | string;\n}\n\nexport interface ReadStateResponse {\n  certificate: ArrayBuffer;\n}\n\nexport interface SubmitResponse {\n  requestId: RequestId;\n  response: {\n    ok: boolean;\n    status: number;\n    statusText: string;\n  };\n}\n\n/**\n * An Agent able to make calls and queries to a Replica.\n */\nexport interface Agent {\n  readonly rootKey: ArrayBuffer | null;\n  /**\n   * Returns the principal ID associated with this agent (by default). It only shows\n   * the principal of the default identity in the agent, which is the principal used\n   * when calls don't specify it.\n   */\n  getPrincipal(): Promise<Principal>;\n\n  /**\n   * Create the request for the read state call.\n   * `readState` uses this internally.\n   * Useful to avoid signing the same request multiple times.\n   */\n  createReadStateRequest?(\n    options: ReadStateOptions,\n    identity?: Identity,\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n  ): Promise<any>;\n\n  /**\n   * Send a read state query to the replica. This includes a list of paths to return,\n   * and will return a Certificate. This will only reject on communication errors,\n   * but the certificate might contain less information than requested.\n   * @param effectiveCanisterId A Canister ID related to this call.\n   * @param options The options for this call.\n   * @param identity Identity for the call. If not specified, uses the instance identity.\n   * @param request The request to send in case it has already been created.\n   */\n  readState(\n    effectiveCanisterId: Principal | string,\n    options: ReadStateOptions,\n    identity?: Identity,\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    request?: any,\n  ): Promise<ReadStateResponse>;\n\n  call(canisterId: Principal | string, fields: CallOptions): Promise<SubmitResponse>;\n\n  /**\n   * Query the status endpoint of the replica. This normally has a few fields that\n   * corresponds to the version of the replica, its root public key, and any other\n   * information made public.\n   * @returns A JsonObject that is essentially a record of fields from the status\n   *     endpoint.\n   */\n  status(): Promise<JsonObject>;\n\n  /**\n   * Send a query call to a canister. See\n   * {@link https://sdk.dfinity.org/docs/interface-spec/#http-query | the interface spec}.\n   * @param canisterId The Principal of the Canister to send the query to. Sending a query to\n   *     the management canister is not supported (as it has no meaning from an agent).\n   * @param options Options to use to create and send the query.\n   * @returns The response from the replica. The Promise will only reject when the communication\n   *     failed. If the query itself failed but no protocol errors happened, the response will\n   *     be of type QueryResponseRejected.\n   */\n  query(canisterId: Principal | string, options: QueryFields): Promise<QueryResponse>;\n\n  /**\n   * By default, the agent is configured to talk to the main Internet Computer,\n   * and verifies responses using a hard-coded public key.\n   *\n   * This function will instruct the agent to ask the endpoint for its public\n   * key, and use that instead. This is required when talking to a local test\n   * instance, for example.\n   *\n   * Only use this when you are  _not_ talking to the main Internet Computer,\n   * otherwise you are prone to man-in-the-middle attacks! Do not call this\n   * function by default.\n   */\n  fetchRootKey(): Promise<ArrayBuffer>;\n  /**\n   * If an application needs to invalidate an identity under certain conditions, an `Agent` may expose an `invalidateIdentity` method.\n   * Invoking this method will set the inner identity used by the `Agent` to `null`.\n   *\n   * A use case for this would be - after a certain period of inactivity, a secure application chooses to invalidate the identity of any `HttpAgent` instances. An invalid identity can be replaced by `Agent.replaceIdentity`\n   */\n  invalidateIdentity?(): void;\n  /**\n   * If an application needs to replace an identity under certain conditions, an `Agent` may expose a `replaceIdentity` method.\n   * Invoking this method will set the inner identity used by the `Agent` to a newly provided identity.\n   *\n   * A use case for this would be - after authenticating using `@dfinity/auth-client`, you can replace the `AnonymousIdentity` of your `Actor` with a `DelegationIdentity`.\n   *\n   * ```Actor.agentOf(defaultActor).replaceIdentity(await authClient.getIdentity());```\n   */\n  replaceIdentity?(identity: Identity): void;\n}\n", "import { Principal } from '@dfinity/principal';\nimport { HttpAgentRequest } from './agent/http/types';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\n\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n\n/**\n * A Key Pair, containing a secret and public key.\n */\nexport interface KeyPair {\n  secretKey: ArrayBuffer;\n  publicKey: PublicKey;\n}\n\n/**\n * A public key that is DER encoded. This is a branded ArrayBuffer.\n */\nexport type DerEncodedPublicKey = ArrayBuffer & { __derEncodedPublicKey__?: void };\n\n/**\n * A signature array buffer.\n */\nexport type Signature = ArrayBuffer & { __signature__: void };\n\n/**\n * A Public Key implementation.\n */\nexport interface PublicKey {\n  // Get the public key bytes encoded with DER.\n  toDer(): DerEncodedPublicKey;\n}\n\n/**\n * A General Identity object. This does not have to be a private key (for example,\n * the Anonymous identity), but it must be able to transform request.\n */\nexport interface Identity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal(): Principal;\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   */\n  transformRequest(request: HttpAgentRequest): Promise<unknown>;\n}\n\n/**\n * An Identity that can sign blobs.\n */\nexport abstract class SignIdentity implements Identity {\n  protected _principal: Principal | undefined;\n\n  /**\n   * Returns the public key that would match this identity's signature.\n   */\n  public abstract getPublicKey(): PublicKey;\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   */\n  public abstract sign(blob: ArrayBuffer): Promise<Signature>;\n\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  public getPrincipal(): Principal {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n    return this._principal;\n  }\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concat(domainSeparator, requestId)),\n      },\n    };\n  }\n}\n\nexport class AnonymousIdentity implements Identity {\n  public getPrincipal(): Principal {\n    return Principal.anonymous();\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    return {\n      ...request,\n      body: { content: request.body },\n    };\n  }\n}\n\n/*\n * We need to communicate with other agents on the page about identities,\n * but those messages may need to go across boundaries where it's not possible to\n * serialize/deserialize object prototypes easily.\n * So these are lightweight, serializable objects that contain enough information to recreate\n * SignIdentities, but don't commit to having all methods of SignIdentity.\n *\n * Use Case:\n * * DOM Events that let differently-versioned components communicate to one another about\n *   Identities, even if they're using slightly different versions of agent packages to\n *   create/interpret them.\n */\nexport interface AnonymousIdentityDescriptor {\n  type: 'AnonymousIdentity';\n}\nexport interface PublicKeyIdentityDescriptor {\n  type: 'PublicKeyIdentity';\n  publicKey: string;\n}\nexport type IdentityDescriptor = AnonymousIdentityDescriptor | PublicKeyIdentityDescriptor;\n\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(\n  identity: SignIdentity | AnonymousIdentity,\n): IdentityDescriptor {\n  const identityIndicator: IdentityDescriptor =\n    'getPublicKey' in identity\n      ? { type: 'PublicKeyIdentity', publicKey: toHex(identity.getPublicKey().toDer()) }\n      : { type: 'AnonymousIdentity' };\n  return identityIndicator;\n}\n", "import type { Principal } from '@dfinity/principal';\nimport { Expiry } from './transforms';\nimport { lebEncode } from '@dfinity/candid';\n\n/**\n * @internal\n */\nexport const enum Endpoint {\n  Query = 'read',\n  ReadState = 'read_state',\n  Call = 'call',\n}\n\n// An HttpAgent request, before it gets encoded and sent to the server.\n// We create an empty request that we will fill later.\nexport type HttpAgentRequest =\n  | HttpAgentQueryRequest\n  | HttpAgentSubmitRequest\n  | HttpAgentReadStateRequest;\n\nexport interface HttpAgentBaseRequest {\n  readonly endpoint: Endpoint;\n  request: RequestInit;\n}\n\nexport interface HttpAgentSubmitRequest extends HttpAgentBaseRequest {\n  readonly endpoint: Endpoint.Call;\n  body: CallRequest;\n}\n\nexport interface HttpAgentQueryRequest extends HttpAgentBaseRequest {\n  readonly endpoint: Endpoint.Query;\n  body: ReadRequest;\n}\n\nexport interface HttpAgentReadStateRequest extends HttpAgentBaseRequest {\n  readonly endpoint: Endpoint.ReadState;\n  body: ReadRequest;\n}\n\nexport interface Signed<T> {\n  content: T;\n  sender_pubkey: ArrayBuffer;\n  sender_sig: ArrayBuffer;\n}\n\nexport interface UnSigned<T> {\n  content: T;\n}\n\nexport type Envelope<T> = Signed<T> | UnSigned<T>;\n\nexport interface HttpAgentRequestTransformFn {\n  (args: HttpAgentRequest): Promise<HttpAgentRequest | undefined | void>;\n  priority?: number;\n}\n\n// The fields in a \"call\" submit request.\n// tslint:disable:camel-case\nexport interface CallRequest extends Record<string, any> {\n  request_type: SubmitRequestType.Call;\n  canister_id: Principal;\n  method_name: string;\n  arg: ArrayBuffer;\n  sender: Uint8Array | Principal;\n  ingress_expiry: Expiry;\n}\n// tslint:enable:camel-case\n\n// The types of values allowed in the `request_type` field for submit requests.\nexport enum SubmitRequestType {\n  Call = 'call',\n}\n\n// The types of values allowed in the `request_type` field for read requests.\nexport const enum ReadRequestType {\n  Query = 'query',\n  ReadState = 'read_state',\n}\n\n// The fields in a \"query\" read request.\nexport interface QueryRequest extends Record<string, any> {\n  request_type: ReadRequestType.Query;\n  canister_id: Principal;\n  method_name: string;\n  arg: ArrayBuffer;\n  sender: Uint8Array | Principal;\n  ingress_expiry: Expiry;\n}\n\nexport interface ReadStateRequest extends Record<string, any> {\n  request_type: ReadRequestType.ReadState;\n  paths: ArrayBuffer[][];\n  ingress_expiry: Expiry;\n  sender: Uint8Array | Principal;\n}\n\nexport type ReadRequest = QueryRequest | ReadStateRequest;\n\n// A Nonce that can be used for calls.\nexport type Nonce = Uint8Array & { __nonce__: void };\n\n/**\n * Create a random Nonce, based on date and a random suffix.\n */\nexport function makeNonce(): Nonce {\n  // Encode 128 bits.\n  const buffer = new ArrayBuffer(16);\n  const view = new DataView(buffer);\n  const now = BigInt(+Date.now());\n  const randHi = Math.floor(Math.random() * 0xffffffff);\n  const randLo = Math.floor(Math.random() * 0xffffffff);\n  // Fix for IOS < 14.8 setBigUint64 absence\n  if (typeof view.setBigUint64 === 'function') {\n    view.setBigUint64(0, now);\n  } else {\n    const TWO_TO_THE_32 = BigInt(1) << BigInt(32);\n    view.setUint32(0, Number(now >> BigInt(32)));\n    view.setUint32(4, Number(now % TWO_TO_THE_32));\n  }\n  view.setUint32(8, randHi);\n  view.setUint32(12, randLo);\n\n  return buffer as Nonce;\n}\n", "import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport { Endpoint, HttpAgentRequest, HttpAgentRequestTransformFn, makeNonce, Nonce } from './types';\nimport { toHex } from '../../utils/buffer';\n\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1_000_000);\n\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);\n\nexport class Expiry {\n  private readonly _value: bigint;\n\n  constructor(deltaInMSec: number) {\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    this._value =\n      (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) *\n      NANOSECONDS_PER_MILLISECONDS;\n  }\n\n  public toCBOR(): cbor.CborValue {\n    // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n    return cbor.value.u64(this._value.toString(16), 16);\n  }\n\n  public toHash(): ArrayBuffer {\n    return lebEncode(this._value);\n  }\n}\n\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn: () => Nonce = makeNonce): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    const nonce = nonceFn();\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers ? new Headers(request.request.headers) : new Headers();\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === Endpoint.Call) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds: number): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n  };\n}\n", "import { JsonObject } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity, Identity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { RequestId, requestIdOf } from '../../request_id';\nimport { fromHex } from '../../utils/buffer';\nimport {\n  Agent,\n  QueryFields,\n  QueryResponse,\n  ReadStateOptions,\n  ReadStateResponse,\n  SubmitResponse,\n} from '../api';\nimport { Expiry, makeNonceTransform } from './transforms';\nimport {\n  CallRequest,\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpAgentSubmitRequest,\n  makeNonce,\n  QueryRequest,\n  ReadRequestType,\n  SubmitRequestType,\n} from './types';\n\nexport * from './transforms';\nexport { Nonce, makeNonce } from './types';\n\nexport enum RequestStatusResponseStatus {\n  Received = 'received',\n  Processing = 'processing',\n  Replied = 'replied',\n  Rejected = 'rejected',\n  Unknown = 'unknown',\n  Done = 'done',\n}\n\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY =\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n  'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n  '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n  'b01291091c5f87b98883463f98091a0baaae';\n\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\n\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\n\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\n\nclass HttpDefaultFetchError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\n\n// HttpAgent options that can be used at construction.\nexport interface HttpAgentOptions {\n  // Another HttpAgent to inherit configuration (pipeline and fetch) of. This\n  // is only used at construction.\n  source?: HttpAgent;\n\n  // A surrogate to the global fetch function. Useful for testing.\n  fetch?: typeof fetch;\n\n  // Additional options to pass along to fetch. Will not override fields that\n  // the agent already needs to set\n  // Should follow the RequestInit interface, but we intentially support non-standard fields\n  fetchOptions?: Record<string, unknown>;\n\n  // Additional options to pass along to fetch for the call API.\n  callOptions?: Record<string, unknown>;\n\n  // The host to use for the client. By default, uses the same host as\n  // the current page.\n  host?: string;\n\n  // The principal used to send messages. This cannot be empty at the request\n  // time (will throw).\n  identity?: Identity | Promise<Identity>;\n\n  credentials?: {\n    name: string;\n    password?: string;\n  };\n  /**\n   * Prevents the agent from providing a unique {@link Nonce} with each call.\n   * Enabling may cause rate limiting of identical requests\n   * at the boundary nodes.\n   *\n   * To add your own nonce generation logic, you can use the following:\n   * @example\n   * import {makeNonceTransform, makeNonce} from '@dfinity/agent';\n   * const agent = new HttpAgent({ disableNonce: true });\n   * agent.addTransform(makeNonceTransform(makeNonce);\n   * @default false\n   */\n  disableNonce?: boolean;\n  /**\n   * Number of times to retry requests before throwing an error\n   * @default 3\n   */\n  retryTimes?: number;\n}\n\nfunction getDefaultFetch(): typeof fetch {\n  let defaultFetch;\n\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.',\n      );\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.',\n      );\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError(\n    'Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.',\n  );\n}\n\ntype _RequestResponse = {\n  requestId: RequestId;\n  response: {\n    ok: Response['ok'];\n    status: Response['status'];\n    statusText: Response['statusText'];\n  };\n};\n\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nexport class HttpAgent implements Agent {\n  public rootKey = fromHex(IC_ROOT_KEY);\n  private readonly _pipeline: HttpAgentRequestTransformFn[] = [];\n  private _identity: Promise<Identity> | null;\n  private readonly _fetch: typeof fetch;\n  private readonly _fetchOptions?: Record<string, unknown>;\n  private readonly _callOptions?: Record<string, unknown>;\n  private _timeDiffMsecs = 0;\n  private readonly _host: URL;\n  private readonly _credentials: string | undefined;\n  private _rootKeyFetched = false;\n  private _retryTimes = 3; // Retry requests 3 times before erroring by default\n  public readonly _isAgent = true;\n\n  constructor(options: HttpAgentOptions = {}) {\n    if (options.source) {\n      if (!(options.source instanceof HttpAgent)) {\n        throw new Error(\"An Agent's source can only be another HttpAgent\");\n      }\n      this._pipeline = [...options.source._pipeline];\n      this._identity = options.source._identity;\n      this._fetch = options.source._fetch;\n      this._host = options.source._host;\n      this._credentials = options.source._credentials;\n    } else {\n      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n      this._fetchOptions = options.fetchOptions;\n      this._callOptions = options.callOptions;\n    }\n    if (options.host !== undefined) {\n      if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n        this._host = new URL(window.location.protocol + '//' + options.host);\n      } else {\n        this._host = new URL(options.host);\n      }\n    } else if (options.source !== undefined) {\n      // Safe to ignore here.\n      this._host = options.source._host;\n    } else {\n      const location = typeof window !== 'undefined' ? window.location : undefined;\n      if (!location) {\n        throw new Error('Must specify a host to connect to.');\n      }\n      this._host = new URL(location + '');\n    }\n    // Default is 3, only set if option is provided\n    if (options.retryTimes !== undefined) {\n      this._retryTimes = options.retryTimes;\n    }\n    // Rewrite to avoid redirects\n    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this._host.hostname = IC0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this._host.hostname = ICP0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this._host.hostname = ICP_API_DOMAIN;\n    }\n\n    if (options.credentials) {\n      const { name, password } = options.credentials;\n      this._credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this._identity = Promise.resolve(options.identity || new AnonymousIdentity());\n\n    // Add a nonce transform to ensure calls are unique\n    if (!options.disableNonce) {\n      this.addTransform(makeNonceTransform(makeNonce));\n    }\n  }\n\n  public isLocal(): boolean {\n    const hostname = this._host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('localhost');\n  }\n\n  public addTransform(fn: HttpAgentRequestTransformFn, priority = fn.priority || 0): void {\n    // Keep the pipeline sorted at all time, by priority.\n    const i = this._pipeline.findIndex(x => (x.priority || 0) < priority);\n    this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    if (!this._identity) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    return (await this._identity).getPrincipal();\n  }\n\n  public async call(\n    canisterId: Principal | string,\n    options: {\n      methodName: string;\n      arg: ArrayBuffer;\n      effectiveCanisterId?: Principal | string;\n    },\n    identity?: Identity | Promise<Identity>,\n  ): Promise<SubmitResponse> {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId\n      ? Principal.from(options.effectiveCanisterId)\n      : canister;\n\n    const sender: Principal = id.getPrincipal() || Principal.anonymous();\n\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(this._timeDiffMsecs) > 1_000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);\n    }\n\n    const submit: CallRequest = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest: any = (await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: new Headers({\n          'Content-Type': 'application/cbor',\n          ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n        }),\n      },\n      endpoint: Endpoint.Call,\n      body: submit,\n    })) as HttpAgentSubmitRequest;\n\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n\n    const body = cbor.encode(transformedRequest.body);\n\n    // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n    // calculate the requestId locally.\n\n    const request = this._requestAndRetry(() =>\n      this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), {\n        ...this._callOptions,\n        ...transformedRequest.request,\n        body,\n      }),\n    );\n\n    const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n\n    return {\n      requestId,\n      response: {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n      },\n    };\n  }\n\n  private async _requestAndRetry(request: () => Promise<Response>, tries = 0): Promise<Response> {\n    if (tries > this._retryTimes && this._retryTimes !== 0) {\n      throw new Error(\n        `AgentError: Exceeded configured limit of ${this._retryTimes} retry attempts. Please check your network connection or try again in a few moments`,\n      );\n    }\n    const response = await request();\n    if (!response.ok) {\n      const responseText = await response.clone().text();\n      const errorMessage =\n        `Server returned an error:\\n` +\n        `  Code: ${response.status} (${response.statusText})\\n` +\n        `  Body: ${responseText}\\n`;\n      if (this._retryTimes > tries) {\n        console.warn(errorMessage + `  Retrying request.`);\n        return await this._requestAndRetry(request, tries + 1);\n      } else {\n        throw new Error(errorMessage);\n      }\n    }\n\n    return response;\n  }\n\n  public async query(\n    canisterId: Principal | string,\n    fields: QueryFields,\n    identity?: Identity | Promise<Identity>,\n  ): Promise<QueryResponse> {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n    const sender = id?.getPrincipal() || Principal.anonymous();\n\n    const request: QueryRequest = {\n      request_type: ReadRequestType.Query,\n      canister_id: canister,\n      method_name: fields.methodName,\n      arg: fields.arg,\n      sender,\n      ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n    };\n\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest: any = await this._transform({\n      request: {\n        method: 'POST',\n        headers: new Headers({\n          'Content-Type': 'application/cbor',\n          ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n        }),\n      },\n      endpoint: Endpoint.Query,\n      body: request,\n    });\n\n    // Apply transform for identity.\n    transformedRequest = await id?.transformRequest(transformedRequest);\n\n    const body = cbor.encode(transformedRequest.body);\n    const response = await this._requestAndRetry(() =>\n      this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), {\n        ...this._fetchOptions,\n        ...transformedRequest.request,\n        body,\n      }),\n    );\n\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  public async createReadStateRequest(\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const sender = id?.getPrincipal() || Principal.anonymous();\n\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest: any = await this._transform({\n      request: {\n        method: 'POST',\n        headers: new Headers({\n          'Content-Type': 'application/cbor',\n          ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n        }),\n      },\n      endpoint: Endpoint.ReadState,\n      body: {\n        request_type: ReadRequestType.ReadState,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      },\n    });\n\n    // Apply transform for identity.\n    return id?.transformRequest(transformedRequest);\n  }\n\n  public async readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line\n    request?: any,\n  ): Promise<ReadStateResponse> {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n\n    const transformedRequest = request ?? (await this.createReadStateRequest(fields, identity));\n    const body = cbor.encode(transformedRequest.body);\n\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const response = await this._requestAndRetry(() =>\n      this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), {\n        ...this._fetchOptions,\n        ...transformedRequest.request,\n        body,\n      }),\n    );\n\n    if (!response.ok) {\n      throw new Error(\n        `Server returned an error:\\n` +\n          `  Code: ${response.status} (${response.statusText})\\n` +\n          `  Body: ${await response.text()}\\n`,\n      );\n    }\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {PrincipalLike} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  public async syncTime(canisterId?: Principal): Promise<void> {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        console.log(\n          'Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai',\n        );\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId ?? Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time'],\n      });\n\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        this._timeDiffMsecs = Number(replicaTime as any) - Number(callTime);\n      }\n    } catch (error) {\n      console.error('Caught exception while attempting to sync time:', error);\n    }\n  }\n\n  public async status(): Promise<JsonObject> {\n    const headers: Record<string, string> = this._credentials\n      ? {\n          Authorization: 'Basic ' + btoa(this._credentials),\n        }\n      : {};\n\n    const response = await this._requestAndRetry(() =>\n      this._fetch('' + new URL(`/api/v2/status`, this._host), { headers, ...this._fetchOptions }),\n    );\n\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  public async fetchRootKey(): Promise<ArrayBuffer> {\n    if (!this._rootKeyFetched) {\n      // Hex-encoded version of the replica root key\n      this.rootKey = ((await this.status()) as any).root_key;\n      this._rootKeyFetched = true;\n    }\n    return this.rootKey;\n  }\n\n  public invalidateIdentity(): void {\n    this._identity = null;\n  }\n\n  public replaceIdentity(identity: Identity): void {\n    this._identity = Promise.resolve(identity);\n  }\n\n  protected _transform(request: HttpAgentRequest): Promise<HttpAgentRequest> {\n    let p = Promise.resolve(request);\n\n    for (const fn of this._pipeline) {\n      p = p.then(r => fn(r).then(r2 => r2 || r));\n    }\n\n    return p;\n  }\n}\n", "import { JsonObject } from '@dfinity/candid';\nimport {\n  Agent,\n  CallOptions,\n  QueryFields,\n  QueryResponse,\n  ReadStateOptions,\n  ReadStateResponse,\n  SubmitResponse,\n} from './api';\nimport { Principal } from '@dfinity/principal';\n\nexport enum ProxyMessageKind {\n  Error = 'err',\n  GetPrincipal = 'gp',\n  GetPrincipalResponse = 'gpr',\n  Query = 'q',\n  QueryResponse = 'qr',\n  Call = 'c',\n  CallResponse = 'cr',\n  ReadState = 'rs',\n  ReadStateResponse = 'rsr',\n  Status = 's',\n  StatusResponse = 'sr',\n}\n\nexport interface ProxyMessageBase {\n  id: number;\n  type: ProxyMessageKind;\n}\n\nexport interface ProxyMessageError extends ProxyMessageBase {\n  type: ProxyMessageKind.Error;\n  error: any;\n}\n\nexport interface ProxyMessageGetPrincipal extends ProxyMessageBase {\n  type: ProxyMessageKind.GetPrincipal;\n}\n\nexport interface ProxyMessageGetPrincipalResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.GetPrincipalResponse;\n  response: string;\n}\n\nexport interface ProxyMessageQuery extends ProxyMessageBase {\n  type: ProxyMessageKind.Query;\n  args: [string, QueryFields];\n}\n\nexport interface ProxyMessageQueryResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.QueryResponse;\n  response: QueryResponse;\n}\n\nexport interface ProxyMessageCall extends ProxyMessageBase {\n  type: ProxyMessageKind.Call;\n  args: [string, CallOptions];\n}\n\nexport interface ProxyMessageCallResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.CallResponse;\n  response: SubmitResponse;\n}\n\nexport interface ProxyMessageReadState extends ProxyMessageBase {\n  type: ProxyMessageKind.ReadState;\n  args: [string, ReadStateOptions];\n}\n\nexport interface ProxyMessageReadStateResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.ReadStateResponse;\n  response: ReadStateResponse;\n}\n\nexport interface ProxyMessageStatus extends ProxyMessageBase {\n  type: ProxyMessageKind.Status;\n}\n\nexport interface ProxyMessageStatusResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.StatusResponse;\n  response: JsonObject;\n}\n\nexport type ProxyMessage =\n  | ProxyMessageError\n  | ProxyMessageGetPrincipal\n  | ProxyMessageGetPrincipalResponse\n  | ProxyMessageQuery\n  | ProxyMessageQueryResponse\n  | ProxyMessageCall\n  | ProxyMessageReadState\n  | ProxyMessageReadStateResponse\n  | ProxyMessageCallResponse\n  | ProxyMessageStatus\n  | ProxyMessageStatusResponse;\n\n// A Stub Agent that forwards calls to another Agent implementation.\nexport class ProxyStubAgent {\n  constructor(private _frontend: (msg: ProxyMessage) => void, private _agent: Agent) {}\n\n  public onmessage(msg: ProxyMessage): void {\n    switch (msg.type) {\n      case ProxyMessageKind.GetPrincipal:\n        this._agent.getPrincipal().then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.GetPrincipalResponse,\n            response: response.toText(),\n          });\n        });\n        break;\n      case ProxyMessageKind.Query:\n        this._agent.query(...msg.args).then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.QueryResponse,\n            response,\n          });\n        });\n        break;\n      case ProxyMessageKind.Call:\n        this._agent.call(...msg.args).then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.CallResponse,\n            response,\n          });\n        });\n        break;\n      case ProxyMessageKind.ReadState:\n        this._agent.readState(...msg.args).then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.ReadStateResponse,\n            response,\n          });\n        });\n        break;\n      case ProxyMessageKind.Status:\n        this._agent.status().then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.StatusResponse,\n            response,\n          });\n        });\n        break;\n\n      default:\n        throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);\n    }\n  }\n}\n\n// An Agent that forwards calls to a backend. The calls are serialized\nexport class ProxyAgent implements Agent {\n  private _nextId = 0;\n  private _pendingCalls = new Map<number, [(resolve: any) => void, (reject: any) => void]>();\n  public rootKey = null;\n\n  constructor(private _backend: (msg: ProxyMessage) => void) {}\n\n  public onmessage(msg: ProxyMessage): void {\n    const id = msg.id;\n\n    const maybePromise = this._pendingCalls.get(id);\n    if (!maybePromise) {\n      throw new Error('A proxy get the same message twice...');\n    }\n\n    this._pendingCalls.delete(id);\n    const [resolve, reject] = maybePromise;\n\n    switch (msg.type) {\n      case ProxyMessageKind.Error:\n        return reject(msg.error);\n      case ProxyMessageKind.GetPrincipalResponse:\n      case ProxyMessageKind.CallResponse:\n      case ProxyMessageKind.QueryResponse:\n      case ProxyMessageKind.ReadStateResponse:\n      case ProxyMessageKind.StatusResponse:\n        return resolve(msg.response);\n      default:\n        throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);\n    }\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.GetPrincipal,\n    }).then(principal => {\n      if (typeof principal !== 'string') {\n        throw new Error('Invalid principal received.');\n      }\n      return Principal.fromText(principal);\n    });\n  }\n\n  public readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n  ): Promise<ReadStateResponse> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.ReadState,\n      args: [canisterId.toString(), fields],\n    }) as Promise<ReadStateResponse>;\n  }\n\n  public call(canisterId: Principal | string, fields: CallOptions): Promise<SubmitResponse> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.Call,\n      args: [canisterId.toString(), fields],\n    }) as Promise<SubmitResponse>;\n  }\n\n  public status(): Promise<JsonObject> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.Status,\n    }) as Promise<JsonObject>;\n  }\n\n  public query(canisterId: Principal | string, fields: QueryFields): Promise<QueryResponse> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.Query,\n      args: [canisterId.toString(), fields],\n    }) as Promise<QueryResponse>;\n  }\n\n  private async _sendAndWait(msg: ProxyMessage): Promise<unknown> {\n    return new Promise((resolve, reject) => {\n      this._pendingCalls.set(msg.id, [resolve, reject]);\n\n      this._backend(msg);\n    });\n  }\n\n  public async fetchRootKey(): Promise<ArrayBuffer> {\n    // Hex-encoded version of the replica root key\n    const rootKey = ((await this.status()) as any).root_key;\n    this.rootKey = rootKey;\n    return rootKey;\n  }\n}\n", "import { GlobalInternetComputer } from '../index';\nimport { Agent } from './api';\n\nexport * from './api';\nexport * from './http';\nexport * from './proxy';\n\ndeclare const window: GlobalInternetComputer;\ndeclare const global: GlobalInternetComputer;\ndeclare const self: GlobalInternetComputer;\n\nexport function getDefaultAgent(): Agent {\n  const agent =\n    typeof window === 'undefined'\n      ? typeof global === 'undefined'\n        ? typeof self === 'undefined'\n          ? undefined\n          : self.ic.agent\n        : global.ic.agent\n      : window.ic.agent;\n\n  if (!agent) {\n    throw new Error('No Agent could be found.');\n  }\n\n  return agent;\n}\n", "import { Principal } from '@dfinity/principal';\nimport { Agent, RequestStatusResponseStatus } from '../agent';\nimport { Certificate, CreateCertificateOptions } from '../certificate';\nimport { RequestId } from '../request_id';\nimport { toHex } from '../utils/buffer';\n\nexport * as strategy from './strategy';\nexport { defaultStrategy } from './strategy';\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\nexport type PollStrategyFactory = () => PollStrategy;\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  strategy: PollStrategy,\n  // eslint-disable-next-line\n  request?: any,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): Promise<ArrayBuffer> {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request ?? (await agent.createReadStateRequest?.({ paths: [path] }));\n  const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify,\n  });\n  const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return cert.lookup([...path, 'reply'])!;\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code'])!)[0];\n      const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message'])!);\n      throw new Error(\n        `Call was rejected:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Reject code: ${rejectCode}\\n` +\n          `  Reject text: ${rejectMessage}\\n`,\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(\n        `Call was marked as done but we never saw the reply:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n`,\n      );\n  }\n  throw new Error('unreachable');\n}\n", "import { Principal } from '@dfinity/principal';\nimport { RequestStatusResponseStatus } from '../agent';\nimport { toHex } from '../utils/buffer';\nimport { PollStrategy } from './index';\nimport { RequestId } from '../request_id';\n\nexport type Predicate<T> = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<T>;\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy(): PollStrategy {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n\n/**\n * Predicate that returns true once.\n */\nexport function once(): Predicate<boolean> {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition: Predicate<boolean>, timeInMsec: number): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count: number): PollStrategy {\n  let attempts = count;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (--attempts <= 0) {\n      throw new Error(\n        `Failed to retrieve a reply for request after ${count} attempts:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec: number): PollStrategy {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec: number): PollStrategy {\n  const end = Date.now() + timeInMsec;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (Date.now() > end) {\n      throw new Error(\n        `Request timed out after ${timeInMsec} msec:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec: number, backoffFactor: number): PollStrategy {\n  let currentThrottling = startingThrottleInMsec;\n\n  return () =>\n    new Promise(resolve =>\n      setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n      }, currentThrottling),\n    );\n}\n\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies: PollStrategy[]): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}\n", "import { Buffer } from 'buffer/';\nimport {\n  Agent,\n  getDefaultAgent,\n  QueryResponseRejected,\n  QueryResponseStatus,\n  ReplicaRejectCode,\n  SubmitResponse,\n} from './agent';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, PollStrategyFactory, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { RequestId } from './request_id';\nimport { toHex } from './utils/buffer';\nimport { CreateCertificateOptions } from './certificate';\nimport managementCanisterIdl from './canisters/management_idl';\nimport _SERVICE from './canisters/management_service';\n\nexport class ActorCallError extends AgentError {\n  constructor(\n    public readonly canisterId: Principal,\n    public readonly methodName: string,\n    public readonly type: 'query' | 'update',\n    public readonly props: Record<string, string>,\n  ) {\n    super(\n      [\n        `Call failed:`,\n        `  Canister: ${canisterId.toText()}`,\n        `  Method: ${methodName} (${type})`,\n        ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n      ].join('\\n'),\n    );\n  }\n}\n\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly result: QueryResponseRejected,\n  ) {\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: ReplicaRejectCode[result.reject_code] ?? `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message,\n    });\n  }\n}\n\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly requestId: RequestId,\n    public readonly response: SubmitResponse['response'],\n  ) {\n    super(canisterId, methodName, 'update', {\n      'Request ID': toHex(requestId),\n      'HTTP status code': response.status.toString(),\n      'HTTP status text': response.statusText,\n    });\n  }\n}\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * A polling strategy factory that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   */\n  pollingStrategyFactory?: PollStrategyFactory;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret extends unknown = unknown> {\n  (...args: Args): Promise<Ret>;\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * The mode used when installing a canister.\n */\nexport enum CanisterInstallMode {\n  Install = 'install',\n  Reinstall = 'reinstall',\n  Upgrade = 'upgrade',\n}\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static async install(\n    fields: {\n      module: ArrayBuffer;\n      mode?: CanisterInstallMode;\n      arg?: ArrayBuffer;\n    },\n    config: ActorConfig,\n  ): Promise<void> {\n    const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId =\n      typeof config.canisterId === 'string'\n        ? Principal.fromText(config.canisterId)\n        : config.canisterId;\n\n    await getManagementCanister(config).install_code({\n      mode: { [mode]: null } as any,\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId,\n    });\n  }\n\n  public static async createCanister(config?: CallConfig): Promise<Principal> {\n    const { canister_id: canisterId } = await getManagementCanister(\n      config || {},\n    ).provisional_create_canister_with_cycles({ amount: [], settings: [] });\n\n    return canisterId;\n  }\n\n  public static async createAndInstallCanister(\n    interfaceFactory: IDL.InterfaceFactory,\n    fields: {\n      module: ArrayBuffer;\n      arg?: ArrayBuffer;\n    },\n    config?: CallConfig,\n  ): Promise<ActorSubclass> {\n    const canisterId = await this.createCanister(config);\n    await this.install(\n      {\n        ...fields,\n      },\n      { ...config, canisterId },\n    );\n\n    return this.createActor(interfaceFactory, { ...config, canisterId });\n  }\n\n  public static createActorClass(interfaceFactory: IDL.InterfaceFactory): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: ArrayBuffer) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, { methodName, arg });\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected:\n          throw new QueryCallRejectedError(cid, methodName, result);\n\n        case QueryResponseStatus.Replied:\n          return decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const { requestId, response } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n      });\n\n      if (!response.ok) {\n        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n      }\n\n      const pollStrategy = pollingStrategyFactory();\n      const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);\n\n      if (responseBytes !== undefined) {\n        return decodeReturnValue(func.retTypes, responseBytes);\n      } else if (func.retTypes.length === 0) {\n        return undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n\nexport type ManagementCanisterRecord = _SERVICE;\n\n/**\n * Create a management canister actor\n * @param config\n */\nexport function getManagementCanister(config: CallConfig): ActorSubclass<ManagementCanisterRecord> {\n  function transform(_methodName: string, args: unknown[], _callConfig: CallConfig) {\n    const first = args[0] as any;\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id as unknown);\n    }\n    return { effectiveCanisterId };\n  }\n\n  return Actor.createActor<ManagementCanisterRecord>(managementCanisterIdl, {\n    ...config,\n    canisterId: Principal.fromHex(''),\n    ...{\n      callTransform: transform,\n      queryTransform: transform,\n    },\n  });\n}\n", "/**\n * This file is generated from the candid for asset management.\n */\n/* tslint:disable */\n// @ts-ignore\nexport default ({ IDL }) => {\n  const canister_id = IDL.Principal;\n  const definite_canister_settings = IDL.Record({\n    controllers: IDL.Vec(IDL.Principal),\n    freezing_threshold: IDL.Nat,\n    memory_allocation: IDL.Nat,\n    compute_allocation: IDL.Nat,\n  });\n  const canister_settings = IDL.Record({\n    controllers: IDL.Opt(IDL.Vec(IDL.Principal)),\n    freezing_threshold: IDL.Opt(IDL.Nat),\n    memory_allocation: IDL.Opt(IDL.Nat),\n    compute_allocation: IDL.Opt(IDL.Nat),\n  });\n  const wasm_module = IDL.Vec(IDL.Nat8);\n  return IDL.Service({\n    canister_status: IDL.Func(\n      [IDL.Record({ canister_id: canister_id })],\n      [\n        IDL.Record({\n          status: IDL.Variant({\n            stopped: IDL.Null,\n            stopping: IDL.Null,\n            running: IDL.Null,\n          }),\n          memory_size: IDL.Nat,\n          cycles: IDL.Nat,\n          settings: definite_canister_settings,\n          module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        }),\n      ],\n      [],\n    ),\n    create_canister: IDL.Func(\n      [IDL.Record({ settings: IDL.Opt(canister_settings) })],\n      [IDL.Record({ canister_id: canister_id })],\n      [],\n    ),\n    delete_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n    deposit_cycles: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n    install_code: IDL.Func(\n      [\n        IDL.Record({\n          arg: IDL.Vec(IDL.Nat8),\n          wasm_module: wasm_module,\n          mode: IDL.Variant({\n            reinstall: IDL.Null,\n            upgrade: IDL.Null,\n            install: IDL.Null,\n          }),\n          canister_id: canister_id,\n        }),\n      ],\n      [],\n      [],\n    ),\n    provisional_create_canister_with_cycles: IDL.Func(\n      [\n        IDL.Record({\n          settings: IDL.Opt(canister_settings),\n          amount: IDL.Opt(IDL.Nat),\n        }),\n      ],\n      [IDL.Record({ canister_id: canister_id })],\n      [],\n    ),\n    provisional_top_up_canister: IDL.Func(\n      [IDL.Record({ canister_id: canister_id, amount: IDL.Nat })],\n      [],\n      [],\n    ),\n    raw_rand: IDL.Func([], [IDL.Vec(IDL.Nat8)], []),\n    start_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n    stop_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n    uninstall_code: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n    update_settings: IDL.Func(\n      [\n        IDL.Record({\n          canister_id: IDL.Principal,\n          settings: canister_settings,\n        }),\n      ],\n      [],\n      [],\n    ),\n  });\n};\n", "/**\n * This file is generated from the candid for asset management.\n */\n/* tslint:disable */\n// @ts-ignore\nexport default ({ IDL }) => {\n  return IDL.Service({\n    retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ['query']),\n    store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], []),\n  });\n};\n", "import { Actor, ActorConfig, ActorSubclass, CallConfig } from '../actor';\nimport assetCanister from './asset_idl';\n\n/* tslint:disable */\nexport interface AssetCanisterRecord {\n  store(path: string, content: number[]): Promise<void>;\n  retrieve(path: string): Promise<number[]>;\n}\n/* tslint:enable */\n\n/**\n * Create a management canister actor.\n * @param config\n */\nexport function createAssetCanisterActor(config: ActorConfig) {\n  return Actor.createActor<AssetCanisterRecord>(assetCanister, config);\n}\n", "import { Principal } from '@dfinity/principal';\nimport * as CanisterStatus from './canisterStatus/index';\nimport { IDL } from '@dfinity/candid';\nimport { HttpAgent } from './agent/http';\nimport { Actor, ActorSubclass } from './actor';\n\n/**\n * Retrieves the Candid interface for the specified canister.\n *\n * @param agent The agent to use for the request (usually an `HttpAgent`)\n * @param canisterId A string corresponding to the canister ID\n * @returns Candid source code\n */\nexport async function fetchCandid(canisterId: string, agent?: HttpAgent): Promise<string> {\n  if (!agent) {\n    // Create an anonymous `HttpAgent` (adapted from Candid UI)\n    agent = new HttpAgent();\n    if (agent.isLocal()) {\n      agent.fetchRootKey();\n    }\n  }\n\n  // Attempt to use canister metadata\n  const status = await CanisterStatus.request({\n    agent,\n    canisterId: Principal.fromText(canisterId),\n    paths: ['candid'],\n  });\n  const candid = status.get('candid') as string | undefined;\n  if (candid) {\n    return candid;\n  }\n\n  // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata\n  const tmpHackInterface: IDL.InterfaceFactory = ({ IDL }) =>\n    IDL.Service({\n      __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query']),\n    });\n  const actor: ActorSubclass = Actor.createActor(tmpHackInterface, { agent, canisterId });\n  return (await actor.__get_candid_interface_tmp_hack()) as string;\n}\n"],
  "mappings": "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",
  "names": ["ReplicaRejectCode", "request", "SubmitRequestType", "request", "RequestStatusResponseStatus", "request", "ProxyMessageKind", "request", "import_buffer", "CanisterInstallMode"]
}
